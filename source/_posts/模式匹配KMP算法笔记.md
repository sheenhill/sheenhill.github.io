---
title: 模式匹配KMP算法笔记
date: 2019-04-26 22:38:07
tags: 
- 数据结构
- 笔记
categories: 数据结构与算法
description: 终于找到一种可以理解的KMP算法获取next[j]的值的方法了。
---

KMP的预处理，是对传统暴力的串的模式匹配算法的一种改进，使其不需回溯。

我一直无法理解KMP中获取next[j]的值方法，现在看了这篇文章（[对字符串匹配算法的一点理解](https://mp.weixin.qq.com/s/aC7XEsz3eGSWj3oWHpQE7w)）之后终于会了。

这里记一下我的笔记。

为了计算Next，需要先了解一下前缀，后缀和PMT的概念：

前缀：如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。

后缀：同样可以定义后缀A=SB，其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。

**要注意的是，字符串本身并不是自己的后缀。**

*我一看到这个前缀后缀的定义，就发现跟左右逆元好像啊。通过名称的解释也更容易理解怎么计算next了。*

PMT：字符串的前缀集合与后缀集合的交集中最长元素的长度。比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}，两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。

例如：ababca，当index=3时（前面省略），前缀与后缀最长相等为“ab”，pmt=2；当index=4是，无相等前后缀，pmt=0.

next值就是把整个pmt往后推一位，当index=0时，next=-1,其说明模式串在str[0]之前没有任何用于加速匹配的信息，下一趟应从str的开头即为next++(index=0)处开始匹配，这是为了在算法中更方便使用。

我们可以用表格更清晰地看出：

| str：   | a    | b    | a    | b    | c    | a    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| index： | 0    | 1    | 2    | 3    | 4    | 5    |
| pmt:    | 0    | 0    | 1    | 2    | 0    | 1    |
| next:   | -1   | 0    | 0    | 1    | 2    | 0    |

当模式串的某一个字母失配的时候，根据next表，做相应的位移，避免指针回溯。这就是KMP对暴力匹配算法的优化。