---
title: 最初的开始
date: 2019-04-17 20:23:30
tags: 
- Android
- 填坑记录
categories: Android
description: 这些都是我之前在搭建的网站上写的博客。看到博客上记录的时间，发现时间过得好快，然而我还是这么菜，，，
---

> 漫步于山间的路



## bug解决！radiogroup中的radiobutton焦点不在第一个上面

> 2018-04-08 09:40:42

bug说明：每次进入app时，预设的状态应为上图，之前的bug为：每次进入app“秒表”button为亮色，焦点不在第一个上。

bug解决：
之前因为为了选择每个radiobutton时，有区别则在每个radiobutton中加了的属性，导致每次启动app时，默认为“时钟”界面，“秒表”字体却高亮。将后面三个radiobutton的

android:checked=\"true"

删除就解决了。
补充：
高亮字体代码：

```
<selector xmlns:android="http://schemas.android.com/apk/res/android">

<item android:state_checked="true" android:color="@color/colorThis" />

<item android:state_checked="false" android:color="@color/colorOthers" />

</selector>

<color name="colorThis">#FFFFFF</color>

<color name="colorOthers">#b1abae</color>
```

笨方法实现选择一个button后，改变整个radiogroup颜色：
```java
switch (checkedId){
    case R.id.rb_mian_one:
        vp_main_viewpager.setCurrentItem(0);
        buttonone.setBackgroundColor(Color.parseColor("#4086DB"));
        buttontwo.setBackgroundColor(Color.parseColor("#4086DB"));
        buttonthree.setBackgroundColor(Color.parseColor("#4086DB"));
        buttonfour.setBackgroundColor(Color.parseColor("#4086DB"));
        break;</pre>
<pre>case R.id.rb_mian_two:
    vp_main_viewpager.setCurrentItem(1);
    buttontwo.setBackgroundColor(Color.parseColor("#62B54D"));
    buttonone.setBackgroundColor(Color.parseColor("#62B54D"));
    buttonthree.setBackgroundColor(Color.parseColor("#62B54D"));
    buttonfour.setBackgroundColor(Color.parseColor("#62B54D"));
    break;
case R.id.rb_mian_three:
    vp_main_viewpager.setCurrentItem(2);
    buttonthree.setBackgroundColor(Color.parseColor("#C4B751"));
    buttontwo.setBackgroundColor(Color.parseColor("#C4B751"));
    buttonone.setBackgroundColor(Color.parseColor("#C4B751"));
    buttonfour.setBackgroundColor(Color.parseColor("#C4B751"));
    break;
case R.id.rb_mian_four:
    vp_main_viewpager.setCurrentItem(3);
    buttonfour.setBackgroundColor(Color.parseColor("#1AB39F"));
    buttonone.setBackgroundColor(Color.parseColor("#1AB39F"));
    buttontwo.setBackgroundColor(Color.parseColor("#1AB39F"));
    buttonthree.setBackgroundColor(Color.parseColor("#1AB39F"));
    break;
```

还需要在Activity的onCreate方法中初始化整个radiobutton：
```java
buttonone.setBackgroundColor(Color.parseColor("#4086DB"));
buttontwo.setBackgroundColor(Color.parseColor("#4086DB"));
buttonthree.setBackgroundColor(Color.parseColor("#4086DB"));
buttonfour.setBackgroundColor(Color.parseColor("#4086DB"));
```

修改：直接更新radiogroup的颜色：
```java
rg_main_radio.setBackgroundColor(Color.parseColor("#4086DB"));
```

bug说明：bug为：每次进入app的radio第二个button为亮色，焦点不在第一个上。
bug解决：
之前因为为了选择每个radiobutton时，有区别则在每个radiobutton中加了android:checked="true"的属性

将android:checked="true"删除就解决了。

## ANDROID 获取时间

> 2018-04-07 22:28:05

用Calendar获取会导致时间只显示一位数字：

```java
Calendar c = Calendar.getInstance(); 
  tvTime.setText(String.format("%d:%d:%d", c.get(Calendar.HOUR_OF_DAY),c.get(Calendar.MINUTE),c.get(Calendar.SECOND))); 
```

实用方式：

```java
DateFormat df = new SimpleDateFormat(\"HH:mm:ss\");
df.format(new Date());
```

（显示俩位数字的时间，且默认24时制）
&nbsp;
[转载出处](https://blog.csdn.net/chaoyu168/article/details/50729689)

## 基于回调的事件传播——ANDROID

> 2017-10-30 22:59:17
>
> 现在看来就是责任链设计模式，但是这个博主说的是很简单明了

根据书籍《疯狂Android讲义 第二版》中介绍：
当该组件上发生某个按键被按下的事件时，Android系统最先触发的应该是该按键上绑定的事件监听器，接着才触发该组件提供的事件回调方法，然后还会传播到该组件所在的Activity。
也就是说，事件扩散的优先级应该是：事件监听器（listener）→事件回调方法(MyButton)→Activity的回调方法(Activity)

该博客给我的启示：[博客链接](http://blog.csdn.net/qq844394093/article/details/50958741)
Android的事件处理机制分为：
①监听 ②回调。
回调机制，就是用组件自身来处理自身的事件，而不是像监听机制一样使用事件监听器。
简单的说，就是写一个类，继承View类或者View类的子类（如Button等），然后重写父类中的某些方法。
该作者用了一个很形象的比喻：

> 那就是事件的扩散（传播），比如
> 一个公司的前台业务员（事件监听器）接到一个尊贵的客人（事件Event），那么这个业务员就是负责端茶递水（处理事件），但是客人（事件Event）有大生意要谈，小小的业务员肯定做不了主，那么他就要向上级报告（return false），\"臣妾做不到啊\"，这时，部门的经理（重写的onTouchEvent）就出面解决问题， 如果还是解决不了，那么再向上级报告（return false），这样一直往上级报告，直到中间某一层解决了客人的需求（return true），那么就不用再向上级报告了。

这个博主就很有灵性！

## Android之坑——TextView.setText方法中参数只能为String型

> 2018-08-02 09:39:34

```xml
/com.example.roy.plan2000h E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.example.roy.plan2000h, PID: 2595
    android.content.res.Resources$NotFoundException: String resource ID #0x1
        at android.content.res.Resources.getText(Resources.java:317)
        at android.content.res.NubiaResources.getText(NubiaResources.java:146)
        at android.widget.TextView.setText(TextView.java:4163)
        at com.example.roy.plan2000h.MyRecyclerViewAdapter.onBindViewHolder(MyRecyclerViewAdapter.java:33)
        at com.example.roy.plan2000h.MyRecyclerViewAdapter.onBindViewHolder(MyRecyclerViewAdapter.java:17)
        at android.support.v7.widget.RecyclerView$Adapter.onBindViewHolder(RecyclerView.java:6673)
```

 一个bug耽误了1个小时，，，，

```java
List<HoursPlan> hourAll=LitePal.select("thisStudyTime").find(HoursPlan.class);
        holder.tvStudyTime.setText(String.valueOf(hourAll.get(position).getThisStudyTime()));
        int count=2000-hourAll.get(position).getThisStudyTime();
        holder.tvResidualTime.setText(String.valueOf(count));
```

这次用litepal框架将数据持久化，并用recyclerView显示出来。

第一次出现这个bug以为是我用litepal查询数据的代码和recyclerView逻辑代码的问题。

然后就是以为我表中定义的thisStudyTime的数据类型有问题，本来是int型，改为了String型，再打算在getText（）中将参数强转成int型。。。。。hhhh

当我再三用分别测试我的litepal代码，recyclerView代码和混合代码都没问题时，我就全用了String型参数，就没有bug了。

[TextView.setText时参数只能是字符/字符串](https://blog.csdn.net/north1989/article/details/52146254)

当我再次针对性地百度时，我才发现这个坑。
参数如果是float,会直接提示,不能使用float类型
参数如果是int类型,写的时候不会报错,但是编译的时候会报错!! 
错误提示大致如下:notFoundResource String xxx
（引用自上面链接）
记一下，万一自己以后又忘了了呢.

## AndroidStudio3.0踩坑实录

> 2017-11-27 19:29:12

当jar包正确导入，当jar包没有重复的包，然而还是确定是包的问题，那么原因很简单：
不要使用 implementation fileTree(include: [''*.jar''], dir: ''libs'')
或者 api fileTree(include: [''*.jar''], dir: ''libs'')（项目形成时会自动生成，需要删除）。
不然lib下的jar均按照api或者implementation方式引入到Module。
这个问题是我在使用okgo框架的时候发现的，我尝试着把 okgo，okhttp和okio都导入（其实不用只导入okgo包就好，其他俩个放在libs就可以了）。

最后感谢这位，[博客链接](https://www.cnblogs.com/liushilin/p/6068098.html)

## Android异常：requestFeature() must be called before adding content

> 2017-10-12 12:44:55

解决方法：
MainActivity extends ActionBarActivity
改为
MainActivity extends Activity
&nbsp;
继承的是ActionBarActivity,改成继承Activity 完美解决！！
原因大概是，由于我用的是Google最新的开发工具，AndroidStudio
百度了很多都是：

<blockquote>super.onCreate(savedInstanceState);
requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);      //设置这种窗口特征只能在，上下两行代码之间。不然也会出现如题的报错。
requestWindowFeature(Window.FEATURE_PROGRESS);
setContentView(R.layout.activity_main);</blockquote>
这次做的实例是显示在标题上的进度条，但是在5.0中没有Holo主题，需要引入value11（这个主题是3.0的）

## 使用9Patch图片作背景

> '2017-10-07 09:50:16'

Android Studio版本：1.0.1 Build 135.1641136
当按钮的内容太多时，Android会自动缩放整张图片，以保证背景图片能够覆盖整个按钮。但这种视觉效果可能不太美观。
9Patch图片可以实现只缩放图片中的某个部分的效果。
这种图片以 .9.png 结尾。
使用方法：

- 在本机上找到Android SDK包的安装路径，进入tools文件夹，双击打开draw9patch.bat；

- 将准备后的png图片拖拽到该窗口中；

- 在图片边缘点击左键，绘制出黑线，即图片需要被拉伸的部分；(如需擦除，可按住shift键的同时点击鼠标左键)

- 保存，生成后缀名为 .9.png 的文件。

- 也可将图片的后缀名直接改成.9.png，放入drawable文件夹中在Android Studio直接打开编辑。

问题：
Android编译遇到点9图片错误：<em>No marked region found along edge. - Found along left edge.</em>
解决：
这个是因为点9图的某一个边（上下左右任何一边）没有涂黑（绘制黑线）。导致编译失败。
每一边都涂黑，涂黑多少看需要，没有位置涂黑的话，将图片ps一下，画布调大，再改。

## ！！！无法触发setOnItemSelectedListener事件

> 2017-07-18 04:08:47

<ul>
 	<li> ListView 中，每一个Item都有俩种状态，被选中和未被选中的状态。</li>
 	<li> 从名字上看，OnItemClickListener一个是点击了就触发了，setOnItemSelectedListener是选中项发生改变就触发。</li>
 	<li> setOnItemClickListener()指的是单击一个条目：</li>
</ul>
<div>    如果你从鼠标滚动过渡到单击一个条目，都会在调用setOnItemClickListener()。
如果你单击了一个条目之前没选择任何条目，所 以会触发一个onNothingSelected()方法。</div>
```java
list.setOnItemClickListener(new AdapterView.OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
        System.out.println(names[position]);
    }
});
list.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
    @Override
    public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {
        System.out.println(names[position]+"被选中了");
    }
    @Override
    public void onNothingSelected(AdapterView&lt;?&gt; adapterView) {
    }
});
```

可是我的真机为什么触发不了（logcat没有显示“被选中了”）！！！
<h4>解释一：</h4>
<em>一般这个问题都是对OnItemSelectedListener这个事件的误读引起的，OnItemSelectedListener是用来监听【选中某一项】的事件，不是【点击】某一项的事件，虽然点击能引发选中事件，但不是必然的，一般用按键或者鼠标滚轮移动焦点都会产生这个选中事件。</em>
(也就是说，在不触屏（不点击）的情况下，在电视或者手机上做一个模拟生成选中某一项的按钮，便会产生事件？)

## Android小问题，AS的系统为Handler引用错误类

> '2017-09-26 20:36:11'

Error:(35, 35) 错误: <匿名com.example.a.framelayouttest.MainActivity$1>不是抽象的, 并且未覆盖Handler中的抽象方法publish(LogRecord)

eg:Handler handler=new Handler()

错误原因： 
自动import系统错将java.util.logging.Handler包import进来了；
解决方法： 
手动去掉import java.util.logging.Handler; 
手动加上import android.os.Handler;

## 今天不经意间碰到了Installation failed due to invalid APK file!问题

> '2017-06-06 16:32:27'

代码没有错误,但是运行时会出现下面的问题

Installing test.apk...\r\nInstallation failed due to invalid APK file!
Please check logcat output for more details.

导致安装不成功。

最终我找到问题所在了.发现我的包名前面加了一条下划线“_1code”，如果新建的工程以数字加下划线开头（工程名为：2_1code），会导致包名前面出现一个下划线。

所以重新建一个工程，同样的代码运行就正常了。

> 这个命名的坑，也是绝了






